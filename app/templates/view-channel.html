{% extends 'base.html' %}
{% load staticfiles %}
{% load filters %}

{% block content %}
    <link rel="stylesheet" href='{% static 'css/style-view-channel.css' %}'/>
    <script src="//cdn.jsdelivr.net/npm/clappr@latest/dist/clappr.min.js"></script>
    <script src='//cdn.jsdelivr.net/npm/@clappr/hlsjs-playback@latest/dist/hlsjs-playback.min.js'></script>
    <script type="text/javascript"
            src="//cdn.jsdelivr.net/gh/clappr/clappr-level-selector-plugin@latest/dist/level-selector.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@clappr/stats-plugin@latest/dist/clappr-stats.min.js"
            type="text/javascript"></script>

    <div class="row">
        <div class="col-xs-6">
            <a href="{% url 'index' %}"
               class="btn btn-default">Voltar</a>
        </div>
        <div class="col-xs-6">
            {% if not canal.category.site.name == 'topcanais' %}
                <a href="{% url 'collect-canal' canal.pk %}"
                   class="btn btn-warning pull-right">Update</a>
            {% endif %}
        </div>
    </div>
    <br/>
    <div class="row">
        <div class="col-xs-3">
            <img src="{{ canal.img_url }}" class="img-thumbnail img-responsive" style="background-color: #0d3349"/>
        </div>
        <div class="col-xs-7">
            <h1 class=""><b>{{ canal.title }}</b></h1>
            <h2></h2>
        </div>
    </div>
    <br/>
    {% if program_1 %}
        <div class="row">
            <div class="col-xs-12">
                <section class="bottom-box">
                    <section class="nowProg">
                        <span class="nameprog">{{ program_1.titulo }}</span>
                        <span class="hourprog">{{ program_1.inicio|convert_time }}</span>
                        <img src="{{ program_1.imagemUrl }}"
                             data-toggle="tooltip" data-placement="bottom"
                             title="{{ program_1.sinopse }}"
                             alt="{{ program_1.titulo }}">
                    </section>
                    <section class="timeline" data-inicio="{{ program_1.inicio }}" data-fim="{{ program_1.fim }}">
                        <div class="progress" style="width: 0%;">
                            <div class="pointer-progress" style="left: 0%;"></div>
                        </div>
                    </section>
                    <section class="nextProg">
                        <span class="nameprog">{{ program_2.titulo }}</span>
                        <span class="hourprog">{{ program_2.inicio|convert_time }}</span>
                        <img src="{{ program_2.imagemUrl }}"
                             data-toggle="tooltip" data-placement="bottom"
                             title="{{ program_2.sinopse }}"
                             alt="{{ program_2.titulo }}">
                    </section>
                </section>
                <script>
                    $(document).ready(function () {
                        setInterval(function () {
                            var dtInicio = $(".timeline").attr('data-inicio');
                            var dtFim = $(".timeline").attr('data-fim');
                            var timeInMs = Math.round(Date.now() / 1000);
                            var porcent = ((timeInMs - dtInicio) * 100) / (dtFim - dtInicio)
                            $(".timeline").find(".progress").width(porcent.toFixed(4) + "%");
                            $(".timeline .pointer-progress").css('left', porcent.toFixed(4) + "%");
                        }, 1000);


                    });
                </script>
            </div>
        </div>
        <br/>
    {% endif %}
    <div class="row">
        <div class="col-xs-12">
            <div class="row">
                {% for link in canal.link_set.all %}
                    <div class="col-xs-4 col-sm-3 col-md-2">
                        <a data-uri="{{ link.m3u8 }}" data-m3u8="{% url 'generate-m3u' %}?uri={{ link.m3u8 }}"
                           href="#{{ link.m3u8 }}"
                           class="btn btn-primary btn-large link">Link {% cycle '1' '2' '3' '4' '5' '6' '7' '8' '9' '10' '11' '12' '13' '14' '15' %} {{ link|get_text_type }}</a>

                    </div>
                {% endfor %}
            </div>
        </div>
    </div>
    <br/>
    <div class="row">
        <div class="col-xs-12">
            <div id="Player">
            </div>
        </div>
    </div>

    <script>

        function getSecondsString(fileSizeInBytes) {
            return fileSizeInBytes.toFixed(1) + ' s';
        };

        function getReadableFileSizeString(fileSizeInBytes) {

            var i = -1;
            var byteUnits = [' kbps', ' Mbps', ' Gbps', ' Tbps', 'Pbps', 'Ebps', 'Zbps', 'Ybps'];
            do {
                fileSizeInBytes = fileSizeInBytes / 1024;
                i++;
            } while (fileSizeInBytes > 1024);

            return Math.max(fileSizeInBytes, 0.1).toFixed(1) + byteUnits[i];
        };
        var r = 3; // Retry attempts
        var player = new Clappr.Player({
            parentId: "#Player",
            autoPlay: false,
            poster: "{{ canal.img_url }}",
            source: "",
            width: '640px',
            height: "360px",
            mediacontrol: {seekbar: "#900", buttons: "#FFFFFF"},
            plugins: [HlsjsPlayback, LevelSelector, ClapprStats],
            clapprStats: {
                // optional: time in miliseconds for each report.
                // default: 5000
                runEach: 5000,
                // optional: callback function.
                // default: console.log
                onReport: (metrics) => {
                    metrics.timers.startup = getSecondsString(metrics.timers.startup / 1000);
                    metrics.timers.watch = getSecondsString(metrics.timers.watch / 1000);
                    metrics.timers.pause = getSecondsString(metrics.timers.pause / 1000);
                    metrics.timers.buffering = getSecondsString(metrics.timers.buffering / 1000);
                    metrics.timers.session = getSecondsString(metrics.timers.session / 1000);
                    metrics.timers.latency = getSecondsString(metrics.timers.latency / 1000);
                    metrics.extra.bufferingPercentage = metrics.extra.bufferingPercentage.toFixed(2) + '%';
                    metrics.extra.watchedPercentage = metrics.extra.watchedPercentage.toFixed(2) + '%';
                    metrics.extra.buffersize = getSecondsString(metrics.extra.buffersize / 1000);
                    metrics.extra.duration = getSecondsString(metrics.extra.duration / 1000);
                    metrics.extra.currentTime = getSecondsString(metrics.extra.currentTime / 1000);
                    metrics.extra.bandwidth = getReadableFileSizeString(metrics.extra.bandwidth);

                    console.table(metrics.timers);
                    console.table(metrics.extra);
                },
                // optional: provide an img uri hosted at the same place as your farm
                // or near of it prefferable 1x1px, without caching.
                // default: none
                //uriToMeasureLatency: '{% static 'img/1x1.png' %}',
                // optional: provide some assets uris hosted at the same place as your farm
                // or near of it prefferable in an uncompressible file format, without caching.
                // default: none
                //urisToMeasureBandwidth: [
                //    {url: '{% static 'img/test100k.db' %}', timeout: 3000},
                //    {url: '{% static 'img/test1Mb.db' %}', timeout: 6000}
                //],
                // optional: number of reports between two consecutive bandwidth tests.
                // default: 10
                runBandwidthTestEvery: 10
            },
            playback: {
                //extrapolatedWindowNumSegments: 24,
                hlsjsConfig: {
                    //número de segmentos necessários para iniciar uma reprodução de transmissão ao vivo.
                    //initialLiveManifestSize: 4,
                    //Comprimento máximo do buffer em segundos. Se o comprimento do buffer for / se tornar menor que esse valor, um novo fragmento será carregado.
                    //maxBufferLength: 30,
                    //Tamanho máximo do buffer 'mínimo' em bytes. Se o tamanho do buffer inicial for maior do que este valor, nenhum fragmento será carregado.
                    //maxBufferSize: 60 * 1000 * 1000,
                    //Tolerância 'máxima' de buracos do buffer entre fragmentos que hls.js pode lidar ao pesquisar o próximo fragmento para carregar.
                    maxBufferHole: 3,
                    //atraso máximo de carregamento de vídeo usado na seleção de nível de início automático:
                    //maxLoadingDelay: 4,
                    //O algoritmo ABR sempre tentará escolher um nível de qualidade que deve evitar rebuffering. então o algoritmo ABR tentará encontrar um nível que deve garantir menos do que o maxStarvationDelaydo buffer.
                    //maxStarvationDelay: 5,
                    //se for esperado que o elemento de mídia seja reproduzido e se currentTime não tiver se movido por mais de highBufferWatchdogPeriode se houver mais de maxBufferHolesegundos no buffer antecipadamente, o hls.js tentará cutucar a reprodução para recuperar a reprodução
                    //highBufferWatchdogPeriod: 3,
                    //No caso de a reprodução continuar a parar após o primeiro toque do indicador de reprodução, currentTime será ainda mais deslocado após nudgeOffset para tentar restaurar a reprodução. media.currentTime + = (nb nudge retry -1) * nudgeOffset
                    //nudgeOffset: 0.1,
                    //Número máximo de tentativas de nudge antes de hls.js gerar um BUFFER_STALLED_ERROR fatal
                    //nudgeMaxRetry: 3,
                    //Este fator de tolerância é usado durante a pesquisa de fragmentos.
                    //maxFragLookUpTolerance: 0.55,
                    //Comprimento máximo do buffer em segundos. Hls.js nunca excederá esse valor, mesmo se ainda maxBufferSize não for atingido.
                    //maxMaxBufferLength: 600,
                    //limite de atraso ao vivo, expresso em múltiplos de EXT-X-TARGETDURATION. se definido como 3, a reprodução começará a partir do fragmento N-3, N sendo o último fragmento da lista de reprodução ao vivo.
                    liveSyncDurationCount: 7,
                    //Comece a pré-busca do fragmento inicial, embora a mídia ainda não esteja anexada.
                    //startFragPrefetch: false,

                }
            },
            events: {
                onError: function (e) {
                    r--;
                    var s = player.options.source;
                    // Replace previous line by the following line to simulate successful recovery
                    // var s = (r > 2) ? player.options.source : 'http://clappr.io/highline.mp4';
                    var t = 10;
                    var retry = function () {
                        if (t === 0) {
                            var o = player.options;
                            o.source = s;
                            player.configure(o);
                            return;
                        }
                        Clappr.$('#retryCounter').text(t);
                        t--;
                        setTimeout(retry, 1000);
                    };
                    player.configure({
                        autoPlay: true,
                        source: 'playback.error',
                        playbackNotSupportedMessage: 'Network fatal error.' + ((r > 0)
                            ? ' Retrying in <span id="retryCounter"></span> seconds ...'
                            : ' All retry attempts failed'),
                    });
                    if (r > 0) {
                        retry();
                    }
                }
            }
        });

        //player.on(Clappr.Events.PLAYER_STOP, playerStop);

        function playerStop() {
            location.reload();
        }

        player.setVolume(100);
        player.play();

        $(document).ready(function () {
            $('a.link').click(function () {
                var data_m3u8 = $(this).data('m3u8');
                var data_uri = $(this).data('uri');
                var uri = window.location.origin + data_m3u8;
                if (data_m3u8 !== '#') {
                    $.get("{% url 'collect-buffer'  %}?uri=" + data_uri, function (data) {
                        console.log(data_uri);
                    });
                } else {
                    uri = window.location.origin + '/api/playlist.m3u8?uri=' + data_uri
                }
                console.log('source ', uri);
                player.configure({
                    source: uri, autoPlay: false
                });

            });
        });
    </script>


{% endblock %}
